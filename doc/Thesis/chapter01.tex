% !TEX root = thesis.tex
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Анализ подходов к построению средств повышения качества}
\label{chap:analisys}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

В данном разделе рассматриваются методы повышения качества и их классификация,
ставится проблема их автоматизации. Для решения поставленной проблемы
рассматривается подход на основе метамоделей и производится анализ существующих
решений.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Понятие качества программного обеспечения}
\label{sec:quality}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

Качество ПО - достаточно абстрактное понятие. Многие понимают под ним, например,
ПО, которое не содержит ошибок. Однако это лишь одна из характеристик качества.
В стандарте ISO 8402:1994 ``Quality management and quality
assurance''~\cite{international1994iso} дается следующее определение качества:

\textbf{Качество программного обеспечения} - это совокупность характеристик ПО,
относящихся к его способности удовлетворять установленные и предполагаемые
потребности.

\textbf{Характеристики качества программного обеспечения} - набор свойств
программной продукции, по которым ее качество описывается и оценивается.

На данный момент наиболее распространена и используется многоуровневая модель
качества программного обеспечения, представленная в наборе стандартов ISO 9126.
На верхнем уровне выделено 6 основных характеристик качества ПО, каждую из
которых определяют набором атрибутов, имеющих соответствующие метрики для
последующей оценки (рис.~\ref{fig:quality_model}).

\newpage
\begin{figure}[h]
    \begin{center}
        \includegraphics[width=0.8\textwidth]{quality.png}
    \end{center}
    \caption{Модель качества ПО}
    \label{fig:quality_model}
\end{figure}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Методы повышения качества}
\label{sec:quality_methods}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

В соответствии с определением, данном в подразделе~\ref{sec:quality}, методы
повышения качества - это набор подходов по улучшению характеристик качества
разрабатываемого ПО. Существует две группы подходов по обеспечению качества
программного обеспечения~\cite{itsykson}:

\begin{enumerate}
    \item Подходы, основанные на синтезе ПО
    \item Подходы, основанные на анализе уже созданного ПО
\end{enumerate}

Подходы, основанные на синтезе ПО, используют различные формализации во время
проектирования системы, таким образом позволяя избежать ошибок на более поздних
этапах разработки.

Данные формализации включают в себя:

\begin{itemize}
    \item формальные спецификации
    \item формальные и неформальные описания различных аспектов программной
    системы
    \item архитектурные шаблоны и стили
    \item паттерны проектирования
    \item контрактное программирование
    \item аннотирование программ
    \item верификация моделей программ с использованием частичных спецификаций
    \item использование моделей предметной области для автоматизации
    тестирования программ
\end{itemize}

Подходы, основанные на анализе уже созданного ПО, используются для повышения
качества уже созданного ПО, что позволяет улучшить огромное количество уже
разработанных программных систем, имеющих проблемы с уровнем качества. Данная
группа подходов оперирует функциональными и нефункциональными требованиями к
разработанной системе для доказательства соответствия или приведения
контрпримеров, показывающих несоответствие поставленным требованиям.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Классификация методов обеспечения качества}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

Обычно выделяют следующие базовые классификации методов обеспечения
качества~\cite{itsykson}:

\newpage
\begin{figure}[ht]
    \begin{center}
        \includegraphics[width=\textwidth]{verification_classification.eps}
    \end{center}
    \caption{Схема используемой классификации методов обеспечения качества}
    \label{fig:verification_classification}
\end{figure}

По \emph{формализованности} процедур обеспечения качества методы
подразделяются на следующие категории:

\textbf{Формальные методы} позволяют создавать формальные функциональные
спецификации и модели архитектуры систем, а также осуществлять их преобразование
в программы с последующей верификацией~\cite{formal_methods}. Корректность
полученных результатов гарантируется математическим аппаратом. К таким методам
относятся, например, дедуктивная верификация, проверка моделей и абстрактная
интерпретация.

Эти методы можно применить только к тем свойствам, которые можно выразить в
рамках некоторой математической модели. Построение этой модели не
автоматизируется, а провести анализ таких моделей может лишь специалист. Однако
сама проверка свойств может быть автоматизирована и позволяет находить даже
самые сложные ошибки.

В отличие от формальных методов \textbf{неформальные методы} позволяют находить
ошибки, используя различные артефакты жизненного цикла системы. К их недостаткам
можно отнести невозможность автоматизации~\cite{kulyamin}. Примером
неформального метода является аудит.

По \emph{степени автоматизируемости} методы подразделяются на следующие
группы:

\textbf{Ручные методы} - группа методов, не подлежащая автоматизации. К этому
классу методов обычно относятся все неформальные методы (аудит, парное
программирование).

\textbf{Автоматизированные методы} предполагают частичную автоматизацию процесса
повышения качества. Данные методы предполагают проведение ручных действий
(например, по подготовке модели в методе проверки моделей) и запуск
автоматизированных процедур (над подготовленными моделями).

\textbf{Автоматические} методы не требуют вмешательства специалистов во время
своего выполнения, что позволяет легко интегрировать их в жизненный цикл
разработки ПО. Примером таких методов является модульное регрессионное
тестирование.

По \emph{необходимости запуска} анализируемой программы выделяют следующие
классы методов:

\textbf{Статические методы} позволяют находить ошибки и недочеты в
исходном коде программ или каких-либо иных артефактов (например, формальные
спецификации и аннотации). От остальных методов их отделяет то, что статические
методы использует только исходные тексты программы, что позволяет обнаруживать
ошибки на стадии написания кода. Таким образом, при анализе отсутствует
спецификация программы - описание того, что она делает. Это уменьшает множество
обнаруживаемых ошибок, но позволяет полностью автоматизировать процесс анализа.
Примером статических методов является статический анализ.

\textbf{Динамические методы} используются для анализа и оценки свойств
программной системы по результатам ее реальной работы. Одними из таких методов
являются тестирование и анализ трасс исполнения.

Для применения данных методов необходимо иметь работающую систему (или ее
прототип), поэтому их нельзя использовать на ранних стадиях разработки. К тому
же данные методы позволяют найти только те ошибки в ПО, которые проявляются в
его работе.

\textbf{Гибридные методы} объединяют в себе элементы некоторых способов
повышения качества, описанных выше. Примерами таких методов являются
тестирование на основе моделей (model driven testing)~\cite{Vieira2006} и
мониторинг формальных свойств (runtime
verification)~\cite{runtime_verification}. Цель таких методов - объединить
преимущества уже используемых подходов.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Модели программных систем}
\label{sec:system_models}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

Одной из важнейших составляющих анализа программных систем является построение
модели. Без нее анализатор будет вынужден непосредственно оперировать с исходным
кодом, что влечет за собой усложнение процедур анализа и самого анализатора в
целом.

В зависимости от способа построения и назначения модели, они могут различаться
по структуре и сложности и обладать различными свойствами. Существуют следующие
виды моделей~\cite{itsykson}:

\begin{itemize}
    \item Структурные модели
    \item Поведенческие модели
    \item Гибридные модели
\end{itemize}

Структурные модели во основном используют информацию о синтаксической структуре
анализируемой программы, в то время как поведенческие - информацию о
динамической семантике. Гибридные модели используют оба этих подхода.

\subsubsection{Структурные модели}
\begin{enumerate}
    \item Синтаксическое дерево

    Синтаксическое дерево является результатом разбора программы в
    соответствии с формальной грамматикой языка программирования. Вершины
    этого дерева соответствуют нетерминальным символам грамматики, а листья
    - терминальным.

    \item Абстрактное синтаксическое дерево

    Данная модель получается из обычного синтаксического дерева путем
    удаления нетерминальных вершин с одним потомком и замены части
    терминальных вершин их семантическими атрибутами.
\end{enumerate}

\subsubsection{Поведенческие модели}

\nomenclature{AST}{Abstrac Syntax Tree, абстрактное синтаксическое дерево}
\nomenclature{CFG}{Control Flow Graph, граф потока управления}
\nomenclature{DDG}{Data Dependency Graph, граф зависимостей по данным}
\nomenclature{SSA}{Static Single Assignment, модель программы: однократное
статическое присваивание}

\begin{enumerate}
    \item Граф потока управления

    Граф потока управления представляет потоки управления программы в виде
    ориентированного графа. Вершинами графа являются операторы программы, а дуги
    отображают возможный ход исполнения программы и связывают между собой
    операторы, выполняемые друг за другом.

    \item Граф зависимостей по данным

    Граф зависимостей по данным отображает связь между конструкциями программы,
    зависимыми по используемым данным. Дуги графа соединяют узлы, формирующие
    данные, и узлы, использующие эти данные.

    \item Граф программных зависимостей

    Данная модель объединяет в себе особенности графа потока управления и графа
    зависимости по данным. В графе программных зависимостей присутствуют дуги
    двух типов: информационные дуги отображают зависимости по данным, а
    дуги управления соединяют последовательно выполняемые конструкции.

    \item Представление в виде SSA

    Однократное статическое присваивание (static single assignment) -
    промежуточное представление программы, которое обладает следующими
    свойствами:
        \begin{itemize}
            \item Всем переменным значение может присваиваться только один раз.
            \item Вводится специальный оператор $\phi$-функция, который
            объединяет разные версии локальных переменных.
            \item Все операторы программы представляются в трехоперандной форме.
        \end{itemize}
\end{enumerate}

\subsubsection{Гибридные модели}
\begin{enumerate}
    \item Абстрактный семантический граф

    Данная модель является расширением абстрактного синтаксического дерева путем
    добавления дуг, отражающих некоторые семантически свойства программы,
    например, такие дуги могут связывать определение и использование переменной
    или определение функции и ее вызов.
\end{enumerate}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Метамодели}
\label{sec:metamodels}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

Обобщенное решение задач анализа и верификации основывается на использовании
\emph{метамоделей}~\cite{metamodeling}. В подразделе~\ref{sec:system_models}
были приведены возможные модели, которые могут быть извлечены из описания
системы на каком-либо языке программирования и отображающие различные ее
свойства. Аналогичным образом, как модели определяют язык описания системы,
метамодели определяют язык описания моделей.

Для решения задач проведения различного вида анализа необходимо разработать
такую метамодель, которая бы описывала необходимый набор моделей. Наиболее
подходящей метамоделью является описание на уровне сущностей анализируемой
системы (объектов или функций) и взаимодействия между ними (вызов функции,
обращение к полю объекта). Детализация взаимодействия между сущностями при этом
должна соответствовать поставленным задачам, т.е. существует проблема поиска
компромисса между степенью детализации метамодели (количеством информации,
которое можно из нее извлечь) и уровнем абстракции (независимостью от способа
описания анализируемой системы). С увеличением степени детализации повышается
мощность модели, но тем самым увеличивается ее сложность, так как необходимо
учитывать специфические для каждого языка возможности описания взаимодействия
объектов программной системы. С ростом же уровня абстракции уменьшается класс
задач, для которых применима данная метамодель.

Таким образом, приведенные ранее проблемы можно решить, разработав метамодель,
которая бы описывала набор моделей, хранящий необходимое количество информации
для проведения анализа, но обладающей достаточной простотой для описания
широкого круга программных систем.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Анализ существующих решений}
\label{sec:analysis}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

На данный момент существует лишь небольшое количество инструментов, использующих
метамоделирование. Необходимо сравнить их и выявить их пригодность к решению
поставленных задач.

\subsection{Критерии сравнения}
\label{subsec:criterions}

Для сравнения существующих средств введем следующие критерии оценки:

\begin{table}[ht]
\caption{Критерии сравнения средств метамоделирования}
\begin{tabularx}{\textwidth}{|c|X|X|}
\hline
№ & Критерий & Описание \\ \hline
1 & Извлечение моделей программ & Возможность получения различных моделей (AST, CFG) из анализируемой программы \\ \hline
2 & Подсчет метрик & Возможность расчета метрик \\ \hline
3 & Визуализации & Наличие различных визуализаций свойств системы \\ \hline
4 & Свойства метамодели & Свойства используемой метамодели - независимость от языка, простота использования \\ \hline
5 & API & Язык программирования, на котором написан API системы \\ \hline
6 & Открытость & Возможность бесплатного использования и наличие открытых исходных кодов \\ \hline
\end{tabularx}
\end{table}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Фреймворк Moose}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\nomenclature{Moose}{Платформа для анализа программ}

Moose является платформой для анализа программ и поддерживает большое количество
различных видов анализа~\cite{moose}:

\begin{enumerate}
    \item Построение и визуализация метрик.
    \item Обнаружение клонов.
    \item Построение графа зависимостей между пакетами.
    \item Вывод словаря, используемого в проекте.
    \item Поддержка браузеров исходного кода.
\end{enumerate}

\nomenclature{FAMIX}{Семейство метамоделей, используемых средством Moose}
\nomenclature{XML}{eXtensible Markup Language, расширяемый язык разметки}
\nomenclature{MSE}{язык разметки, используемый средством Moose}

Moose использует целое семейство метамоделей под названием FAMIX. Данное
семейство обладает довольно сложной структурой, упрощенный вид которой приведен
на рис.~\ref{fig:famix_hierarchy}:

\begin{figure}[ht!]
     \begin{center}
         \includegraphics[width=0.8\textwidth]{famix_hierarchy.png}
     \end{center}
     \caption{Структура метамоделей семейства FAMIX}
     \label{fig:famix_hierarchy}
\end{figure}

Анализ программы происходит следующим образом:

\begin{enumerate}
    \item Импортирование входных данных. Импортирование может происходить как
    при помощи встроенных (Moose поддерживает Smalltalk, XML и MSE), так и
    сторонних средств.
    \item После импортирования данные приводятся к одной из метамоделей
    семейства FAMIX.
    \item Применение заданных алгоритмов анализа.
\end{enumerate}

Архитектура средства приведена на рис~\ref{fig:moose_architecture}

\begin{figure}[ht!]
    \begin{center}
        \includegraphics[width=\textwidth]{moose_architecture.png}
    \end{center}
    \caption{Архитектура фреймворка Moose}
    \label{fig:moose_architecture}
\end{figure}

К недостаткам данной среды можно отнести то, что Moose нацелен в первую очередь
на задачи реинжиниринга и обладает слишком избыточной и громоздкой метамоделью
для разработки на ее основе алгоритмов статического анализа и верификации.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Средство SMIILE}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\nomenclature{SMIILE}{Software Metrics Independent of Input LanguagE,
средство для анализа программ}

\nomenclature{eCST}{enriched Concrete Syntax Tree, модель программы,
используемая средством SMIILE}

SMIILE - среда, предназначенная для вычисления метрик анализируемой
системы~\cite{smile}.

В качестве метамодели SMIILE использует представление в виде eCST (enriched
Concrete Syntax Tree), которое представляет собой дерево разбора программы с
добавлением универсальных узлов, что позволяет сделать eCST независимым от
языка программирования, на котором написана анализируемая система.

На рис~\ref{fig:smile_arch} изображена архитектура данного средства:

\begin{figure}[ht!]
    \begin{center}
        \includegraphics[width=0.8\textwidth]{smile_arch.png}
    \end{center}
    \caption{Архитектура SMIILE}
    \label{fig:smile_arch}
\end{figure}

Анализ программы происходит в две фазы:

\begin{enumerate}
    \item Фаза 1
    \begin{enumerate}
        \item Определение языка программирования, на котором написана
        анализируемая программа.
        \item Вызов парсера этого языка для построения CST и преобразование в
        eCST.
        \item Вывод результата в формате XML.
    \end{enumerate}

    \item Фаза 2
    \begin{enumerate}
        \item Считывание eCST из файла.
        \item Подсчет метрик.
        \item Сохранение результата в формате XML.
    \end{enumerate}
\end{enumerate}

Средство SMILE на данный момент не разрабатывается и, помимо подсчета метрик, не
предоставляет никаких других возможностей.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Фреймворк LLVM}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\nomenclature{LLVM}{Low Level Virtual Machine, фреймворк для создания
компиляторов}

LLVM - фреймворк для анализа и трансформации программ. Данный фреймворк
предоставляет информацию для трансформаций компилятору во время компиляции,
линковки и исполнения~\cite{llvm}.

LLVM использует промежуточное представление, в основе которого лежит
представление в виде SSA. Промежуточное представление является набором
RISC-подобных команд и содержит дополнительную информацию более высокого уровня,
например информацию о типах и графе потока управления.

Данный фреймворк обладает следующими особенностями:

\begin{itemize}
    \item Сохранение информации о программе даже во время исполнения и между
    запусками.
    \item Предоставление информации пользователю для профилирования и
    оптимизации.
    \item Промежуточное представление не зависит от языка программирования.
    \item Возможность оптимизации всей системы в целом (после этапа линковки).
\end{itemize}

Архитектура LLVM приведена на рис~\ref{fig:llvm_arch}:

\begin{figure}[ht!]
    \begin{center}
        \includegraphics[width=\textwidth]{llvm_arch.png}
    \end{center}
    \caption{Архитектура LLVM}
    \label{fig:llvm_arch}
\end{figure}

Front-end компиляторы транслируют исходную программу в промежуточное
представление LLVM, которое затем компонуется LLVM-линковщиком. На этой стадии
может проводиться межпроцедурный анализ. Получившийся код затем транслируется
в машинный код для целевой платформы.

Однако, промежуточное представление, используемое в LLVM, обладает
недостаточной полнотой описания, необходимой для подсчета метрик и визуализации
свойств программной системы.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Фреймворк ULF-Ware}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\nomenclature{ULF-Ware}{Unified Language Family softWare, фреймворк для
генерации кода из программных моделей}

\nomenclature{SDL}{Specification and Description Language, язык для описания
моделей программных систем}

ULF-Ware является средством для генерации кода из модели, созданной при помощи
языка SDL (Specification and Description Language)~\cite{metamodeling}. Данное
средство использует метамодель под названием CeeJay, которая предназначена для
описания систем на языках Java и C++.

Архитектура ULF-Ware приведена на рис~\ref{fig:ulf_ware_arch}.

\begin{figure}[htbc!]
    \begin{center}
        \includegraphics[width=\textwidth]{ulf_ware_arch.png}
    \end{center}
    \caption{Архитектура ULF-Ware}
    \label{fig:ulf_ware_arch}
\end{figure}

Генерация кода происходит следующим образом: компилятор SDL создает модель
программы, соответствующую метамодели SDL. После этого происходит трансформация
исходной модели в экземпляр метамодели CeeJay, который обладает всей необходимой
информацией для генерации кода на языке Java или C++.

Ограничением данного средства и метамодели CeeJay является тот факт, что, в силу
специфики задачи, данная метамодель может применяться только для языков Java и
C++.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Результаты анализа}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

Результаты сравнения существующих средств на основе критериев из
подраздела~\ref{subsec:criterions} приведены в таблице~\ref{tab:results}.

\begin{sidewaystable}
\caption{Результаты сравнения существующих решений}
\scriptsize
\begin{tabularx}{\textwidth}{|c|c|X|X|X|X|X|}
\hline
Название & Модели & Метрики & Визуализации & Свойства & API & Лицензия \\ \hline
Moose & - & Метрики размера (количество методов, количество атрибутов, количество свойств) & Визуализация метрик, наличия клонов, зависимостей между пакетами и т.д. & Не зависит от языка, высокий уровень сложности использования & Smalltalk & BSD и MIT \\ \hline
SMIILE & - & Метрики Холстеда, ОО-метрики, цикломатическая сложность и т.д. & - & Не зависит от языка & - (средство не доступно) & - \\ \hline
LLVM & SSA, CFG & - & - & Не зависит от языка, имеет модель в виде SSA & C++ & NCSA Open Source License \\ \hline
ULF-Ware & - & - & - & Только языки Java и C++ & - (средство не доступно) & - \\ \hline
\end{tabularx}
\label{tab:results}
\end{sidewaystable}

\section{Вывод}

В ходе данного раздела были рассмотрены методы повышения качества и модели
программ, используемые в этих методах, а также была описаны проблемы
автоматизации их реализации. Для решения данных проблем был предложен подход на
основе метамодели, абстрагированной от языка описания программ, и проведен
анализ существующих решений.

На основе проведенного анализа было выявлено, что наиболее подходящим средством
(из рассмотренных) для решения поставленных проблем является среда Moose.
Однако, метамодель, используемая Moose отличается высокой сложностью
взаимодействия и работы с ней, так как она предназначена для решения слишком
широкого круга задач. К тому же данное средство ориентировано в основном на
визуализацию свойств, мало связанных с задачами статического анализа и
верификации.

Поэтому, для решения задач построения моделей программ и подсчета метрик было
принято решение о разработке языконезависимой метамодели и инструментальной
среды, позволяющей извлекать эти модели и визуализировать свойства
анализируемого ПО.
