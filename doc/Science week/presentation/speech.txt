[слайд 1]
Здравствуйте. Меня зовут Половцев Александр, я являюсь студентом
кафедры КСПТ, и сегодня я расскажу про инструментальную среду для анализа
программных систем, которую я разрабатываю рамках своей магистерской
диссертации.

[слайд 2]
При разработке различных анализаторов и верификаторов, проведении
аудита и т.д. часто решаются похожие задачи - это
1. Построение различных моделей программы (AST, CFG и т.д.)
2. Построение метрик
3. Задачи реинжиниринга, такие как оптимизация и рефакторинг
4. Визуализация свойств системы (например, те же метрики гораздо удобнее
рассматривать наглядно, а не в виде кучи чисел)

(переключаю слайд)

Главная проблема состоит в том, что обычно эти задачи решаются вручную.

[слайд 3]
Разрабатываемое средство призвано автоматизировать решения этих задач, на основе
анализа которых были разработаны следующие требования:
1. Поддержка анализа объектно-ориентированных языков - так как сейчас данная
парадигма является наиболее распространенной, что увеличит количество возможных
анализируемых систем.
2. Извлечение различных моделей - эти модели могут затем непосредственно визуализироваться,
либо использоваться в различных методах анализа
3. Встроенные средства отображения
4. Модульная расширяемая структура - пользователь сможет писать свои методы анализа,
комбинировать их, дополнять имеющиеся средства визуализации, писать парсеры для
разных языков программирования.
5. Экспорт артефактов во внешние отчеты - например, результаты анализа могут быть
представлены в виде html-отчета
6. Предоставление API - следствие из п.2.

[слайд 4]
На основе данных требований была предложена следующая архитектура разрабатываемой
среды:

Всю среду можно разбить на 3 составные части:

1. В центре системы находится так называемая метамодель - модель для описания
моделей. Задача метамодели - обеспечить независимое от языка программирования
представление системы, в то же время достаточно мощное для извлечения моделей,
перечисленных раннее.
2. Построением метамодели из исходного кода анализируемой системы занимаются
специализированные преобразователи. Их задача - из исходного кода получить
некое промежуточное представление системы, которое затем будет импортировано в
виде метамодели.
3. Собственно над метамоделью и будут проводиться различные преобразования, на
ее основе будут разрабатываться алгоритмы анализа. Данный подход позволяет
унифицировать весь набор алгоритмов, абстрагируясь от языка, на котором написана
анализируемая система.

Рассмотрим более подробно каждую составляющую.

[слайд 5]
Как я уже говорил, метамодель является ядром системы и является независимой от
языка описания программы. На основе решаемых задач к ней предъявляются следующие
требования:
1. Независимость от языка программирования
2. Достаточная мощность
3. Расширяемость - невозможно изначально предусмотреть все свойства, необходимые
пользователю. Поэтому предлагается сделать метамодель расширяемой.

Возникает вопрос, а существуют ли уже разработанные решения?

[слайд 6]
Оказывается да, и это решение называется Meta Object Facility. Оно разработано
группой OMG (которая подарила нам UML, собственно сам UML описывается при помощи
MOF). MOF является стандартом и метаметамоделью для построения объектно-ориентированных метамоделей и
предлагает 4-х уровневую архитектуру.

[слайд 7]
1. Информационный уровень - собственно программная система.
2. Уровень модели- например, это может быть UML-описание.
3. Уровень метамодели
4. Уровень метаметамодели

[слайд 8]
Так как сам стандарт MOF очень громоздкий, то он был модифицирован в соответствии
с поставленными требованиями. На данном слайде приведена упрощенная диаграмма
классов разработанной метамодели. На самом деле зависимостей между классами намного
больше, просто полная диаграмма не влезла бы на этот слайд. (Вкратце говорю, что там есть)

[слайд 9]
Далее рассмотрим блок преобразователей. Как я уже говорил, их задача - преобразование
исходного кода к промежуточному представлению. К сожалению, необходимо писать
свой преобразователь для каждого языка. Для упрощения реализации преобразователей
предполагается разработать библиотеку, которая бы абстрагировала бы пользователя
от промежуточного формата. Общая архитектура преобразователя приведена на данном
слайде.

[слайд 10]
Остановлюсь чуть подробнее на промежуточном представлении. Оно, собственно, должно
корректно отображать все свойства метамодели. Тут на помощь вновь приходит OMG,
которая разработала формат XMI специально для сериализации метамоделей.

[слайд 11]
На данном слайде приведен пример сериализованной UML модели для класса Address.

[слайд 12]
Что получилось в итоге.

[слайд 13]
Направления разработки.
